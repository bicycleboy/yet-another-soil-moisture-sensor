# Device specific parameters
substitutions:
  purpose: "Soil moisture sensor"
  name: esp32-c6
  friendly_name: esp32-c6
  # uncomment here and in wifi section
  #device_ip: 192.168.0.<your ip here>
  #gateway_ip: 192.168.0.1
  adc_pin: GPIO0
  sensor_power_pin: GPIO18
  sda_pin: GPIO22
  scl_pin: GPIO23
  user_led_pin: GPIO15
  wake_pin: GPIO2
  sensor_update_interval: "15s"
  wifi_sensor_update_interval: "60s"
  battery_sensor_update_interval: "15s"
  
# --- Device info ---
esphome:
  name: ${name}
  friendly_name: ${friendly_name}
  name_add_mac_suffix: False
  on_boot:
    priority: 800
    then:
      - script.execute: flash_led
      # For c6 use a switch to enable external antenna
      - wifi.disable:
      - output.turn_off: wifi_enable     # LOW = enable
      - delay: 100ms
      - switch.turn_on: antenna_ext  
      - wifi.enable:

# for c6, support is incomplete 4/25?
esp32:
  board: seeed_xiao_esp32c6
  framework:
    type: esp-idf

#external_components temporary work around - ADC not fully supported on c6 yet.  Only works on gpio0

external_components:
  - source:
      # https://github.com/leon-v/esphome/blob/adc_one_shot_C2/esphome/components/adc
      type: git
      url: https://github.com/leon-v/esphome
      ref: adc_one_shot_C2
    components: [ adc ]
    refresh: 0s

# --- Network and core services

# visual indication esp32 has booted and searching for wifi, log to ha
wifi:
  ssid: !secret wifi_ssid
  password: !secret wifi_password
  # uncomment to set static IP
# manual_ip:
#    static_ip: ${device_ip}
#    gateway: ${gateway_ip}
#    subnet: 255.255.255.0
  on_connect:
    - then:
        - script.stop: flash_led
        - light.turn_on:
            id: user_led  
        - switch.turn_on: sensor_power
        - delay: 5s
        - homeassistant.event:
            event: esphome.esp32-boot
            data:
              message: "${friendly_name} ${purpose}"
              notify: 'true' # set to true for debgging, visibility
        - lambda: |-
            ESP_LOGI("wifi", "Wi-Fi connected! (%d dB)", (int)id(wifi_signal_db).state);
  on_disconnect:
    - then:
        - logger.log: "Wi-Fi disconnected!"
        - script.execute: flash_led

# Enable Home Assistant API
api:
# replace below with your encyption key or leave commented out
#  encryption:
#    key: "etc="
  services:
    - service: enter_deep_sleep
      variables:
        duration: int
      then:
        - lambda: |-
            id(sleep_duration_ms) = duration;
        - script.execute: script_enter_deep_sleep

# enable ota updates
ota:
  - platform: esphome
    # replace with your password or leave commented out
    # password: "etc"

# Enable logging
logger:

# --- Globals ---

globals:
  - id: sleep_duration_ms
    type: int
    restore_value: no
    initial_value: '60000'

# sync with ha time
time:
  - platform: homeassistant 
    id: ha_time

# --- Interfaces ---

i2c:
  # for MA17048 battery monitor
  sda: ${sda_pin}
  scl: ${scl_pin}
  scan: true
  id: i2c_max17043


# --- Outputs and peripherals ---

output:
  # For c6 GPIO3 activates external antenna switch GPIO14
  - platform: gpio
    pin: GPIO3
    id: wifi_enable


switch:
  # Define a GPIO for powering sensor on/off
  - platform: gpio
    id: sensor_power
    pin: ${sensor_power_pin}
    restore_mode: ALWAYS_OFF
  # For c6 PIN14 enables external entenna
  - platform: gpio
    pin: GPIO14
    restore_mode: ALWAYS_ON
    name: "External Wifi Antenna On/Off"
    id: antenna_ext

light:
  # Common to esp32-c6
  - platform: status_led
    pin: 
      number: ${user_led_pin}
      inverted: true
    name: "User Led"
    id: user_led
    

# --- Sensors and inputs ---
sensor:
  #----- Common sensors
  - platform: wifi_signal
    name: "WiFi Signal Strength"
    id: wifi_signal_db
    update_interval: ${wifi_sensor_update_interval}
    entity_category: "diagnostic"

# Soil moisture sensor
  - platform: adc
    pin: ${adc_pin}
    name: Soil Moisture Sensor
    id:  soil_moisture
    accuracy_decimals: 1
    update_interval: 5s
    icon: mdi:flower
    unit_of_measurement: '%'
#    attenuation: 11db
    filters:
      - lambda: |-
          if (x > 2.4) { 				// if over 2.4 volts, we are dry
            return 0;
          } else if (x < 1.0) { 			// if under 0.264 volts, we are fully saturated
            return 100;
          } else {
          // use a linear fit for any values in between
          //  return (2.4-x) / (2.4-1.0) * 100.0; 	 
          
          // Quadratic - more senstive at low moisture levels 
            float normalized = (2.4 - x) / (2.4 - 1.0); // 0.0 to 1.0
            return pow(normalized, 0.5) * 100.0; // square root curve
          }

# battery sensor
  - platform: max17043
    id: max17043_id
    i2c_id: i2c_max17043
    battery_voltage:
      name: "Battery Voltage"
    battery_level:
      name: "Battery"

# ---  Logic ---

script:
  # Flash (on connect)
  - id: flash_led
    mode: restart
    then:
      - light.turn_on:
          id: user_led
      - delay: 200ms
      - light.turn_off: user_led
      - delay: 200ms
      - script.execute: flash_led

  # Flash when entering deep sleep
  - id: flash_enter_deep_sleep
    mode: single
    then:
      - light.turn_on:
          id: user_led
      - delay:  500ms
      - light.turn_off: user_led
      - delay: 500ms
      - light.turn_on: user_led
      - delay: 500ms
      - light.turn_off: user_led

  # Deep sleep requested from home assistant (more flexible than hardcoding here)
  - id: script_enter_deep_sleep
    mode: single
    then:
      - script.execute: flash_enter_deep_sleep
      - lambda: |-
          ESP_LOGI("script", "Command recieved, entering deep sleep in 10 secs for %d secs at %s", id(sleep_duration_ms)/1000, id(ha_time).now().strftime("%Y-%m-%d %H:%M:%S").c_str()); 
      - homeassistant.event:
          event: esphome.esp32-sleep
          data:
            message: "${friendly_name} ${purpose}"
            notify: 'true' # set to true for debgging, visibility
            # Pass wake time back to ha for logging/notification
            wake_at: !lambda |-
              if (id(ha_time).now().is_valid()) {
                auto now = id(ha_time).now();
                auto wake_ts = now.timestamp + (id(sleep_duration_ms) / 1000);
                return wake_ts;  // returns epoch seconds
              } else {
                return int64_t(0);
              }
      - max17043.sleep_mode: max17043_id
      # give time for above to execute
      - delay: 10s
      - switch.turn_off: sensor_power
      - deep_sleep.enter:
          sleep_duration: !lambda 'return id(sleep_duration_ms);'
     


   
    
# enable deep sleep, set sleep and run duration at runtime via api
deep_sleep:
  wakeup_pin: ${wake_pin}
  wakeup_pin_mode: INVERT_WAKEUP

